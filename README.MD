# 1일차
- 컨트롤러에서 엔티티 타입으로 바로 받으면 안되고 별도의 DTO를 만들어서 사용해야한다.
  1. 컨트롤러에 @Valid로 검증로직을 넣으면 엔티티에도 @NotEmpty를 넣어야한다. 만약 해당 엔티티를 사용하는 다른 API에서는 @NotEmpty가 필요없다면? 문제가 발생한다.
     -> 응답 스펙을 맞추기 위한 로직추가
  2. name이 userName으로 바뀌는(API 스펙이 변경되는) 경우 API 스펙이 깨진다. 엔티티는 여러곳에서 사용하는건데 엔티티를 바꾸면 많은 API스펙이 깨지는 문제가 있다.
- update문을 굳이 리턴하지 않는 이유는 커맨드와 쿼리가 같이 있는 꼴로 바뀌기 때문이다. 무슨말이냐면 id를 가지고 Member를 변경했는데 Member를 리턴한다면 Member를 조회한 것 처럼 보이기 때문에 변경의 경우 id만 리턴하거나 리턴하지 않는다. 다만 Member를 리턴하면 클라이언트가 갱신된 최신 데이터를 알 수 있다는 장점이 있다.

# 2일차
- Member조회에 제네릭이 있는 이유는 클라이언트 요구에 따라 dto가 언제든지 바뀌기 때문에 한 번 감싼다.
- 지연로딩은 해당 칼럼을 호출할 때 값을 가져온다. 그 전까지는 ByteBuddy라는 프록시로 값을 감싸놓는다. xToOne 연관관계 호출시 ByteBuddy 에러가 발생하면 프록시 문제다.

# 3일차
- 조인한 뒤 DTO로 데이터를 받으면 N + 1 문제가 발생한다. 처음 주문 전체 데이터를 조회하는 쿼리 1번 + 주문마다 그 안에있는 데이터를 조회하는 쿼리 N번. 이를 방지하기 위해 FETCH JOIN을 사용한다.
- 단 N + 1은 최악의 경우고 주문에서 회원을 조회할 때 한 회원이 여러번 주문을 했다면 그만큼 횟수가 줄어든다. 한 번 조회할 때마다 영속성 컨텍스트에 등록이 되기 때문에 JPA는 영속성 컨텍스트에 없는 값에 대해서 쿼리를 날린다.
- 엔티티를 바로 조회하는 것의 장점은 재사용성이 높고, 조회 후 값을 수정할 수 있다. DTO로 바로 조회하는 것의 장점은 엔티티보다 성능이 뛰어나다. 다만 재사용성이 떨어지고 코드가 지저분해진다.
- 레포지토리는 가급적 순수한 엔티티를 조회하는데 쓰고 dto를 조회할 때는 simpleQuery같은 패키지를 만들고 쓰자. 유지보수성이 좋아진다.
- 쿼리 방식 선택 순서
  1. 엔티티 DTO 변환
  2. 페치 조인 성능 최적화
  3. 그래도 안되면 DTO 직접 조회
  4. 최후는 네이티브 SQL이나 스프링 JDBC Template사용해서 SQL 직접 사용

# 4일차
- 일대다에서 조인을 하면 데이터가 뻥튀기된다. 일에서 다를 조회할 때 1 : 3 개 데이터가 있다면 1개가 조회돼야하는데 3개가 조회된다.