# 1일차
- 컨트롤러에서 엔티티 타입으로 바로 받으면 안되고 별도의 DTO를 만들어서 사용해야한다.
  1. 컨트롤러에 @Valid로 검증로직을 넣으면 엔티티에도 @NotEmpty를 넣어야한다. 만약 해당 엔티티를 사용하는 다른 API에서는 @NotEmpty가 필요없다면? 문제가 발생한다.
     -> 응답 스펙을 맞추기 위한 로직추가
  2. name이 userName으로 바뀌는(API 스펙이 변경되는) 경우 API 스펙이 깨진다. 엔티티는 여러곳에서 사용하는건데 엔티티를 바꾸면 많은 API스펙이 깨지는 문제가 있다.
- update문을 굳이 리턴하지 않는 이유는 커맨드와 쿼리가 같이 있는 꼴로 바뀌기 때문이다. 무슨말이냐면 id를 가지고 Member를 변경했는데 Member를 리턴한다면 Member를 조회한 것 처럼 보이기 때문에 변경의 경우 id만 리턴하거나 리턴하지 않는다. 다만 Member를 리턴하면 클라이언트가 갱신된 최신 데이터를 알 수 있다는 장점이 있다.

# 2일차
- Member조회에 제네릭이 있는 이유는 클라이언트 요구에 따라 dto가 언제든지 바뀌기 때문에 한 번 감싼다.
- 지연로딩은 해당 칼럼을 호출할 때 값을 가져온다. 그 전까지는 ByteBuddy라는 프록시로 값을 감싸놓는다. xToOne 연관관계 호출시 ByteBuddy 에러가 발생하면 프록시 문제다.

# 3일차
- 조인한 뒤 DTO로 데이터를 받으면 N + 1 문제가 발생한다. 처음 주문 전체 데이터를 조회하는 쿼리 1번 + 주문마다 그 안에있는 데이터를 조회하는 쿼리 N번. 이를 방지하기 위해 FETCH JOIN을 사용한다.
- 단 N + 1은 최악의 경우고 주문에서 회원을 조회할 때 한 회원이 여러번 주문을 했다면 그만큼 횟수가 줄어든다. 한 번 조회할 때마다 영속성 컨텍스트에 등록이 되기 때문에 JPA는 영속성 컨텍스트에 없는 값에 대해서 쿼리를 날린다.
- 엔티티를 바로 조회하는 것의 장점은 재사용성이 높고, 조회 후 값을 수정할 수 있다. DTO로 바로 조회하는 것의 장점은 엔티티보다 성능이 뛰어나다. 다만 재사용성이 떨어지고 코드가 지저분해진다.
- 레포지토리는 가급적 순수한 엔티티를 조회하는데 쓰고 dto를 조회할 때는 simpleQuery같은 패키지를 만들고 쓰자. 유지보수성이 좋아진다.
- 쿼리 방식 선택 순서
  1. 엔티티 DTO 변환
  2. 페치 조인 성능 최적화
  3. 그래도 안되면 DTO 직접 조회
  4. 최후는 네이티브 SQL이나 스프링 JDBC Template사용해서 SQL 직접 사용

# 4일차
- 일대다에서 조인을 하면 데이터가 뻥튀기된다. 일에서 다를 조회할 때 1 : 3 개 데이터가 있다면 1개가 조회돼야하는데 3개가 조회된다.
- DTO안에도 엔티티가 있으면 안된다. 그 안에 엔티티도 dto로 바꿔야함. 
- 일대다 V2도 N+1문제가 있다. N+1보다 더 많음.
- order와 OrderItems를 일대다 fetchJoin하면 데이터가 뻥튀기 된다.
  - Order 데이터 2개, OrderItems데이터 2개를 조인한 경우 한 데이터 총 4개 생성
  - DB입장에서 한 Order당 각각의 OrderItems가 나와서 총 4개가 나오는게 맞지만 fetchJoin은 한 번에 데이터를 다 가져오기 때문에 app상에서 한 오더에 OrderItems 2개가 전부 담기고 OrderItems의 개수만큼 이 동작이 반복된다. -> 중복데이터가 반복됨
  - 우리는 2개의 Order만 원한다. OrderItems가 몇 개든 select o from Order o 쿼리에선 Order만 있으면되기 때문에 distinct 활용
  - 실제 쿼리에서 distinct를 사용하면 적용안된다. OrderItems의 값이 다 다르기 때문. 단 JPA의 쿼리에서 사용하면 Order값이 중복인지 체크하기 떄문에 잘 적용된다.
  - 단점으로 페이징처리가 불가능하고 컬렉션 페치조인은 반드시 컬렉션 하나에만 사용하자.
# 5일차
- 일대다관계에 서 일을 기준으로 페이징 하는 것이 목적인데 데이터는 다를 기준으로 생성된다. XtoOne은 페치조인해도 이상없다.
- 일대다 컬렉션은 지연로딩으로 조회하고 hibernate에서 BatchSize를 적용해서 가져온다.
- default_batch_fetch_size에 숫자를 넣으면 그 숫자만큼 In쿼리로 값을 한번에 가져온다. 오더 2, 오더아이템2일 때 batch_size를 2이상 넣으면 오더아이템을 한번에 가져온다.
- oneToMany에서 DTO로 바로 받을 때 한 번에 받을 수 없다. many부분은 dto에서 빼고 수행한 뒤 dto부분만 따로 만들어서 수행하고 전 결과값에 넣어줘야한다. -> 이 방법은 N+1문제 발생

# 6일차
- 핵심 비즈니스로직은 repository에 만들고 화면과 관련된 쿼리 api는 별도의 query패키지를 만들고 그 안에 넣는게 유지보수 측면에서 좋다.
- xToOne 관계는 조인으로 가져오고 xtoMany 관계는 따로 루프를 돌면서 일일이 넣어줬다.